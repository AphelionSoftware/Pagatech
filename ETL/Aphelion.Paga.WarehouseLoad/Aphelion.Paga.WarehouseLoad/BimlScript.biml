
<# var DestConnection = SchemaManager.CreateConnectionNode("SchemaProvider", "Data Source=.\\sql2012;Initial Catalog=Paga_EDW;Provider=SQLNCLI11.1;Integrated Security=SSPI;"); #>

	
<# var DestSchema = DestConnection.ImportDB("", "", ImportOptions.ExcludeViews); #>
<# var DestTables = DestConnection.GenerateTableNodes(); #>
	

	
<# var strLookup = ""; #>
<# var strLookup_U = ""; #>

<Biml xmlns="http://schemas.varigence.com/biml.xsd">
  <Connections>
    <Connection Name="Paga_Staging" ConnectionString="Data Source=.\sql2012;Initial Catalog=Paga_Staging;Provider=SQLNCLI11.1;Integrated Security=SSPI;" CreateInProject="true"/>
    <Connection Name="Paga_EDW" ConnectionString="Data Source=.\sql2012;Initial Catalog=Paga_EDW;Provider=SQLNCLI11.1;Integrated Security=SSPI;" CreateInProject="true"/>
    <Connection Name="Paga_Errors" ConnectionString="Data Source=.\sql2012;Initial Catalog=Paga_Errors;Provider=SQLNCLI11.1;Integrated Security=SSPI;" CreateInProject="true"/>
  </Connections>
	<PackageProjects>
    <PackageProject Name="Aphelion.Paga.WarehouseLoad">
	 
    </PackageProject>
  </PackageProjects>

  <Packages>

	<# 
		string PackageListQuery = "SELECT "+
											"PackageName = CONVERT(CHAR(4),(list.LoadGroup + list.rn)) +'_' + StagingTableName, "+
											"list.TABLE_SCHEMA, "+
											"list.TABLE_NAME, "+
											"list.BaseQuery, "+
											"list.KeyColumn, "+
											"list.SourceTable, "+
											"ErrorTable = StagingTableName, "+
											"list.UpdateQuery "+
										"FROM "+
										"(  "+
											"SELECT  "+
												"ROW_NUMBER()OVER(PARTITION BY pl.lg ORDER BY TABLE_SCHEMA,TABLE_NAME) AS rn, "+
												"StagingTableName = (TABLE_SCHEMA +'_' +TABLE_NAME), "+
												"pl.TABLE_SCHEMA,  "+
												"pl.TABLE_NAME,  "+
												"BaseQuery = pl.bq,  "+
												"KeyColumn = pl.kc,  "+
												"LoadGroup = pl.lg, "+
												"SourceTable = pl.st,  "+
												"UpdateQuery = pl.uq  "+
											"FROM  "+
											"(  "+
												"SELECT  "+
													"package_list.TABLE_SCHEMA,  "+
													"package_list.TABLE_NAME,  "+
													"CONVERT(VARCHAR(MAX),MAX(UpdateQuery)) AS uq,  "+
													"CONVERT(VARCHAR(MAX),MAX(BaseQuery)) AS bq,  "+
													"CONVERT(VARCHAR(MAX),MAX(KeyColumn)) AS kc,  "+
													"CONVERT(INT ,MAX(LoadGroup)) AS lg,  "+
													"CONVERT(VARCHAR(MAX),MAX(SourceTable)) AS st  "+
												"FROM  "+
												"(  "+
													"SELECT  "+
														"table_list.StagingTableName,  "+
														"table_list.TABLE_SCHEMA,  "+
														"table_list.TABLE_NAME, "+ 
														"CASE  "+
																"WHEN ext_prop.name =  'UpdateQuery'  "+
																"THEN CONVERT(VARCHAR(MAX),ext_prop.value)  "+
														"END as UpdateQuery,  "+
														"CASE	 "+
																"WHEN ext_prop.name =  'BaseQuery'  "+
																"THEN CONVERT(VARCHAR(max),ext_prop.value)  "+
														"END as BaseQuery,  "+
														"CASE	 "+
																"WHEN ext_prop.name =  'KeyColumn'  "+
																"THEN CONVERT(VARCHAR(max),ext_prop.value)  "+
														"END as KeyColumn,  "+
														"CASE	 "+
																"WHEN ext_prop.name =  'LoadGroup'  "+
																"THEN CONVERT(INT,ext_prop.value)  "+
														"END as LoadGroup,  "+
														"CASE	 "+
																"WHEN ext_prop.name =  'SourceTable'  "+
																"THEN CONVERT(VARCHAR(max),ext_prop.value)  "+
														"END as SourceTable  "+
													"FROM  "+
													"(  "+
														"SELECT   "+
															"StagingTableName = SCHEMA_NAME(t.schema_id) +'_' + t.name,  "+
															"TABLE_SCHEMA = SCHEMA_NAME(t.schema_id),  "+
															"TABLE_NAME = t.name,  "+
															"t.object_id  "+
														"FROM sys.tables AS t  "+
													") table_list  "+
													"INNER JOIN sys.extended_properties AS ext_prop ON   "+
														"table_list.object_id = ext_prop.major_id  "+
													"WHERE  "+ 
														"ext_prop.name = 'UpdateQuery' OR ext_prop.name = 'BaseQuery' OR ext_prop.name = 'KeyColumn' OR ext_prop.name = 'SourceTable' OR ext_prop.name = 'LoadGroup' "+
												") AS package_list  "+
												"GROUP BY  "+
													"package_list.TABLE_SCHEMA,  "+
													"package_list.TABLE_NAME  "+
												") as pl  "+
											"WHERE   "+
												"pl.bq IS NOT NULL  "+
												
										") AS list "+
										"INNER JOIN "+
										"("+
											"SELECT "+
												"tsg.TABLE_SCHEMA "+
											"FROM "+
												"( "+
												"SELECT "+
													"ROW_NUMBER()OVER(ORDER BY ts.TABLE_SCHEMA) as seed, "+
													"ts.TABLE_SCHEMA "+
												"FROM "+
												"( "+
													"SELECT DISTINCT  "+
														"t.TABLE_SCHEMA "+
													"FROM INFORMATION_SCHEMA.TABLES AS t "+
													"WHERE "+
														"t.TABLE_TYPE = 'BASE TABLE' "+
												") as ts "+
											") AS tsg "+
										") as prefix ON "+
											"list.TABLE_SCHEMA = prefix.TABLE_SCHEMA ";
	  
			DataTable tableNamesToImport = ExternalDataAccess.GetDataTable(DestConnection.ConnectionString, PackageListQuery); 
			foreach (DataRow row in tableNamesToImport.Rows)
                { 
				string PackageName = row[0].ToString();
				string TableSchema = row[1].ToString();
				string TableName = row[2].ToString();
				string errTable = row[6].ToString();
				string UpdateQuery = "&quot;" + row[7].ToString()+"&quot;";
				string CountQuery = "&quot;SELECT CAST(COUNT(*) AS INT) AS _count FROM Staging." +TableSchema +"_" +TableName +" &quot; +@[User::EndOfQuery]";
				string SetInactiveQuery =	"&quot;UPDATE ["+TableSchema +"].["+TableName+"] " +
											"SET IsActive = 0  " +
											"WHERE  " +
											"	EXISTS " +
											"	( " +
											"		SELECT 1  " +
											"		FROM Paga_Staging.Staging."+TableSchema +"_" +TableName +" as stg " +
											"		WHERE  " +
											"			stg.SourceKey = sourceKey " +
											"			AND SYS_CHANGE_OPERATION = 'D' " +
											"			AND SYS_CHANGE_VERSION = &quot; +(DT_WSTR, 20)@[$Package::ChangeVersion] +&quot;" +
											"	)&quot;";
#>	
	<Package Name="<#=PackageName#>" ConstraintMode="Parallel" ProtectionLevel="EncryptSensitiveWithUserKey"  MaxErrorCount="2000"  DelayValidation="true">
		<Parameters>
			<Parameter Name="ChangeVersion" DataType="Decimal">0</Parameter>
		</Parameters>
	
		<Variables>
			<Variable Name="intQueueID" DataType="Int32" >0</Variable>
			<Variable Name="intErrorCount" DataType="Int32" >0</Variable>
			<Variable Name="strPackageName" DataType="String"><#=PackageName#></Variable>
			<Variable Name="ChangeOperation" DataType="String">I</Variable>
			<Variable Name="GetRowCount" DataType="String" EvaluateAsExpression="true"><#=CountQuery#></Variable>
			<Variable Name="EndOfQuery" DataType="String" EvaluateAsExpression="true">"WHERE SYS_CHANGE_VERSION >= " +(DT_WSTR, 20)@[$Package::ChangeVersion] +" AND SYS_CHANGE_OPERATION = '" + @[User::ChangeOperation] +"'"</Variable>
			<Variable Name="RowCount" DataType="Int32">0</Variable>
			<Variable Name="GetData" DataType="String" EvaluateAsExpression="true">"SELECT * FROM [Staging].[<#=TableSchema#>_<#=TableName#>] " + @[User::EndOfQuery]</Variable>
			<Variable Name="InactiveQuery" DataType="String" EvaluateAsExpression="true"><#=SetInactiveQuery#></Variable>
			<Variable Name="UpdateQuery" DataType="String" EvaluateAsExpression="true"><#=UpdateQuery#></Variable>
 		</Variables>

	   <Tasks>
			<!-- This needs to go -->
			<ExecuteSQL Name="SQL_Truncate_Error_<#=errTable#>" ConnectionName="Paga_Errors" DelayValidation="true">
			  <DirectInput>TRUNCATE TABLE [Errors].[<#=errTable#>]
			  </DirectInput>
			</ExecuteSQL>

			<Container Name="SEQ_Load_New_Rows" ConstraintMode="Parallel" DelayValidation="true">
				<PrecedenceConstraints>
					<Inputs>
						<Input OutputPathName="SQL_Truncate_Error_<#=errTable#>.Output"> </Input>
					</Inputs>
				</PrecedenceConstraints>
				<Tasks>
					<Expression Name="ET_Set_ChangeOperation" Expression="@[User::ChangeOperation] = &quot;I&quot;" DelayValidation="true"> </Expression>
					<ExecuteSQL Name="EST_CheckForInserts" ConnectionName="Paga_Staging" ResultSet="SingleRow" DelayValidation="true">
						<VariableInput VariableName="User.GetRowCount" /><Results><Result Name="_count" VariableName="User.RowCount"/></Results>
						<PrecedenceConstraints>
							<Inputs>
								<Input OutputPathName="ET_Set_ChangeOperation.Output" />
							</Inputs>
						</PrecedenceConstraints>
					</ExecuteSQL>
					<Dataflow Name="DFT_Load_<#=TableSchema#>_<#=TableName#>"  MaxErrorCount="2000" DelayValidation="true">
						<PrecedenceConstraints>
						<Inputs>
							<Input OutputPathName="EST_CheckForInserts.Output" EvaluationOperation="ExpressionAndConstraint" EvaluationValue="Success" Expression="@[User::RowCount] > 0"/>
						</Inputs>
						</PrecedenceConstraints>
						
						<Transformations>
							<OleDbSource Name="OLE_SRC_Staging_<#=TableSchema#>_<#=TableName#>" ConnectionName="Paga_Staging">
							  <VariableInput VariableName="User.GetData"></VariableInput>
							</OleDbSource>
							<# 
								strLookup ="OLE_SRC_Staging_" + TableSchema +"_" + TableName + ".Output";
								string FKColumnQuery = "SELECT DISTINCT "+
															"C.name AS ForeignKeyColumn, "+
															"'[' + FS.name + '].[' + FT.name + ']' AS ForeignTable, "+
															"FC.name AS ForeignTableColumn, "+
															"LEFT(C.Name, len(C.name)-2) + 'SourceKey' AS SourceLookupColumn, "+
															"CAST(C.is_nullable AS VARCHAR) AS IsNullable "+
														"FROM sys.foreign_key_columns AS FK "+
														"INNER JOIN sys.tables AS T ON "+
															"FK.parent_object_id = T.object_id "+
														"INNER JOIN sys.columns AS C ON "+
															"FK.parent_object_id = C.object_id "+
															"AND FK.parent_column_id = C.column_id "+
														"INNER JOIN sys.tables AS FT ON "+
															"FK.referenced_object_id = FT.object_id "+
														"INNER JOIN sys.columns AS FC ON "+
															"FK.referenced_object_id = FC.object_id "+
															"AND FK.referenced_column_id = FC.column_id "+
														"INNER JOIN sys.schemas AS FS ON "+
															"FT.schema_id = FS.schema_id "+
														"WHERE "+
															"C.name != ('Active') "+
															"AND FT.Name NOT IN ('DimDate', 'DimTime') "+
															"AND T.name = '"+ TableName + "'";
								DataTable FKColumns = ExternalDataAccess.GetDataTable(DestConnection.ConnectionString, FKColumnQuery);
								string IsNullable ="" ;

								foreach (DataRow FKColumn in FKColumns.Rows) { 
									IsNullable = "" + FKColumn["IsNullable"];
									if(IsNullable=="1") { #>
									<Lookup Name="LKP_<#=FKColumn["ForeignKeyColumn"]#>" OleDbConnectionName="Paga_EDW" NoMatchBehavior="IgnoreFailure">
									<InputPath OutputPathName="<#=strLookup#>" />
									  <DirectInput>SELECT SourceKey, <#=FKColumn["ForeignTableColumn"]#> FROM <#=FKColumn["ForeignTable"]#></DirectInput>
									  <Inputs>
										<Column SourceColumn="<#=FKColumn["SourceLookupColumn"]#>" TargetColumn="SourceKey" />
									  </Inputs>
									  <Outputs>
										<Column SourceColumn="<#=FKColumn["ForeignTableColumn"]#>" TargetColumn="<#=FKColumn["ForeignKeyColumn"]#>" />
									  </Outputs>
									</Lookup>
								<#	} else
									 { #>
										<Lookup Name="LKP_<#=FKColumn["ForeignKeyColumn"]#>" OleDbConnectionName="Paga_EDW" NoMatchBehavior="RedirectRowsToErrorOutput">
										<InputPath OutputPathName="<#=strLookup#>" />
										  <DirectInput>SELECT SourceKey, <#=FKColumn["ForeignTableColumn"]#> FROM <#=FKColumn["ForeignTable"]#></DirectInput>
										  <Inputs>
											<Column SourceColumn="<#=FKColumn["SourceLookupColumn"]#>" TargetColumn="SourceKey" />
										  </Inputs>
										  <Outputs>
											<Column SourceColumn="<#=FKColumn["ForeignTableColumn"]#>" TargetColumn="<#=FKColumn["ForeignKeyColumn"]#>" />
										  </Outputs>
										</Lookup>
									 <DerivedColumns Name="DC_AddErrorDetails_<#=FKColumn["ForeignKeyColumn"]#>">
										<InputPath OutputPathName="LKP_<#=FKColumn["ForeignKeyColumn"]#>.Error" />
              							<Columns>
											<Column Name="PackageName" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)@[System::PackageName]</Column>
											<Column Name="QueueID" DataType="Int32" >@[User::intQueueID]</Column>
											<Column Name="ErrorType" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)("Failed Lookup <#=FKColumn["ForeignKeyColumn"]#>")</Column>
											<Column Name="SSISErrorCode" DataType="Int32" >ErrorCode</Column>
											<Column Name="SSISErrorColumn" DataType="Int32" >ErrorColumn</Column>
										</Columns>
									</DerivedColumns>
									<RowCount Name="RC_CountErrors_<#=FKColumn["ForeignKeyColumn"]#>" VariableName="User.intErrorCount">
										 <InputPath OutputPathName="DC_AddErrorDetails_<#=FKColumn["ForeignKeyColumn"]#>.Output" />
									</RowCount>
									<OleDbDestination Name="OLE_DST_Error_<#=TableSchema#>_<#=TableName#>_<#=FKColumn["ForeignKeyColumn"]#>" ConnectionName="Paga_Errors" MaximumInsertCommitSize="200"  TableLock="false">
										  <InputPath OutputPathName="RC_CountErrors_<#=FKColumn["ForeignKeyColumn"]#>.Output" />
										<ExternalTableOutput Table="[Errors].[<#=errTable#>]" />
									</OleDbDestination>
									<# } 					 
										strLookup = "LKP_" + FKColumn["ForeignKeyColumn"] + ".Match";
									#>
										<!-- end lookup for each-->
							<# } 
					
								string Schema_Table = TableSchema +"_" +TableName;
								string SchemaQualifiedName = TableSchema +"." +TableName;
							#> 
				
							<OleDbDestination Name="OLE_DST_<#=Schema_Table#>" ConnectionName="Paga_EDW">
								<InputPath OutputPathName="<#=strLookup#>" />
								<ExternalTableOutput Table="<#=SchemaQualifiedName#>" />
								<ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
							</OleDbDestination>

		
							<OleDbDestination Name="OLE_DST_Singleton_<#=Schema_Table#>" ConnectionName="Paga_EDW" MaximumInsertCommitSize="1">
							  <InputPath OutputPathName="OLE_DST_<#=Schema_Table#>.Error" />
							  <ExternalTableOutput Table="<#=SchemaQualifiedName#>" />
							  <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
							</OleDbDestination>

							<DerivedColumns Name="DC_AddErrorDetails">
							  <InputPath OutputPathName="OLE_DST_Singleton_<#=Schema_Table#>.Error" />
							  <Columns>
								<Column Name="PackageName" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)@[System::PackageName]</Column>
								<Column Name="QueueID" DataType="Int32" >@[User::intQueueID]</Column>
								<Column Name="ErrorType" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)("Insert")</Column>
								<Column Name="SSISErrorCode" DataType="Int32" >OLE_DST_Singleton_<#=Schema_Table#>.ErrorCode</Column>
								<Column Name="SSISErrorColumn" DataType="Int32" >OLE_DST_Singleton_<#=Schema_Table#>.ErrorColumn</Column>
							  </Columns>
							</DerivedColumns>
							<RowCount Name="RC_CountErrors" VariableName="User.intErrorCount">
							  <InputPath OutputPathName="DC_AddErrorDetails.Output" />
							</RowCount>

							<OleDbDestination Name="OLE_DST_Error_<#=Schema_Table#>" ConnectionName="Paga_Errors" MaximumInsertCommitSize="200" TableLock="false">
								  <InputPath OutputPathName="RC_CountErrors.Output" />
								  <ExternalTableOutput Table="[Errors].[<#=Schema_Table#>]" />
							</OleDbDestination>
							</Transformations>
				
					</Dataflow>
				
				</Tasks>
			</Container>
			
			<Container Name="SEQ_Update_Changed_Rows" ConstraintMode="Parallel" DelayValidation="true">
				<PrecedenceConstraints>
					<Inputs>
						<Input OutputPathName="SEQ_Load_New_Rows.Output"> </Input>
					</Inputs>
				</PrecedenceConstraints>
				<Tasks>
					<Expression Name="ET_Set_ChangeOperation" Expression="@[User::ChangeOperation] = &quot;U&quot;" DelayValidation="true"></Expression>
					<ExecuteSQL Name="EST_CheckForUpdates" ConnectionName="Paga_Staging" ResultSet="SingleRow" DelayValidation="true">
						<VariableInput VariableName="User.GetRowCount" /><Results><Result Name="_count" VariableName="User.RowCount"/></Results>
						<PrecedenceConstraints>
							<Inputs>
								<Input OutputPathName="ET_Set_ChangeOperation.Output" />
							</Inputs>
						</PrecedenceConstraints>
					</ExecuteSQL>
					<Container Name="SEQ_LoadUpdates" ConstraintMode="Parallel" DelayValidation="true">
					<PrecedenceConstraints>
						<Inputs>
							<Input OutputPathName="EST_CheckForUpdates.Output" EvaluationOperation="ExpressionAndConstraint" EvaluationValue="Success" Expression="@[User::RowCount] > 0"/>
						</Inputs>
						</PrecedenceConstraints>
						<Tasks>
							<Dataflow Name="DFT_Load_<#=TableSchema#>_<#=TableName#>"  MaxErrorCount="2000" DelayValidation="true">
											
								<Transformations>
									<OleDbSource Name="OLE_SRC_Staging_<#=TableSchema#>_<#=TableName#>" ConnectionName="Paga_Staging">
									  <VariableInput VariableName="User.GetData"></VariableInput>
									</OleDbSource>
									<# 
										strLookup_U ="OLE_SRC_Staging_" + TableSchema +"_" + TableName + ".Output";
										string FKColumnQuery_U = "SELECT DISTINCT "+
																	"C.name AS ForeignKeyColumn, "+
																	"'[' + FS.name + '].[' + FT.name + ']' AS ForeignTable, "+
																	"FC.name AS ForeignTableColumn, "+
																	"LEFT(C.Name, len(C.name)-2) + 'SourceKey' AS SourceLookupColumn, "+
																	"CAST(C.is_nullable AS VARCHAR) AS IsNullable_U "+
																"FROM sys.foreign_key_columns AS FK "+
																"INNER JOIN sys.tables AS T ON "+
																	"FK.parent_object_id = T.object_id "+
																"INNER JOIN sys.columns AS C ON "+
																	"FK.parent_object_id = C.object_id "+
																	"AND FK.parent_column_id = C.column_id "+
																"INNER JOIN sys.tables AS FT ON "+
																	"FK.referenced_object_id = FT.object_id "+
																"INNER JOIN sys.columns AS FC ON "+
																	"FK.referenced_object_id = FC.object_id "+
																	"AND FK.referenced_column_id = FC.column_id "+
																"INNER JOIN sys.schemas AS FS ON "+
																	"FT.schema_id = FS.schema_id "+
																"WHERE "+
																	"C.name != ('Active') "+
																	"AND FT.Name NOT IN ('DimDate', 'DimTime') "+
																	"AND T.name = '"+ TableName + "'";
										DataTable FKColumns_U = ExternalDataAccess.GetDataTable(DestConnection.ConnectionString, FKColumnQuery_U);
										string IsNullable_U ="" ;

										foreach (DataRow FKColumn in FKColumns_U.Rows) { 
											IsNullable_U = "" + FKColumn["IsNullable_U"];
											if(IsNullable_U=="1") { #>
											<Lookup Name="LKP_<#=FKColumn["ForeignKeyColumn"]#>" OleDbConnectionName="Paga_EDW" NoMatchBehavior="IgnoreFailure">
											<InputPath OutputPathName="<#=strLookup_U#>" />
											  <DirectInput>SELECT SourceKey, <#=FKColumn["ForeignTableColumn"]#> FROM <#=FKColumn["ForeignTable"]#></DirectInput>
											  <Inputs>
												<Column SourceColumn="<#=FKColumn["SourceLookupColumn"]#>" TargetColumn="SourceKey" />
											  </Inputs>
											  <Outputs>
												<Column SourceColumn="<#=FKColumn["ForeignTableColumn"]#>" TargetColumn="<#=FKColumn["ForeignKeyColumn"]#>" />
											  </Outputs>
											</Lookup>
										<#	} else
											 { #>
												<Lookup Name="LKP_<#=FKColumn["ForeignKeyColumn"]#>" OleDbConnectionName="Paga_EDW" NoMatchBehavior="RedirectRowsToErrorOutput">
												<InputPath OutputPathName="<#=strLookup_U#>" />
												  <DirectInput>SELECT SourceKey, <#=FKColumn["ForeignTableColumn"]#> FROM <#=FKColumn["ForeignTable"]#></DirectInput>
												  <Inputs>
													<Column SourceColumn="<#=FKColumn["SourceLookupColumn"]#>" TargetColumn="SourceKey" />
												  </Inputs>
												  <Outputs>
													<Column SourceColumn="<#=FKColumn["ForeignTableColumn"]#>" TargetColumn="<#=FKColumn["ForeignKeyColumn"]#>" />
												  </Outputs>
												</Lookup>
											 <DerivedColumns Name="DC_AddErrorDetails_<#=FKColumn["ForeignKeyColumn"]#>">
												<InputPath OutputPathName="LKP_<#=FKColumn["ForeignKeyColumn"]#>.Error" />
              									<Columns>
													<Column Name="PackageName" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)@[System::PackageName]</Column>
													<Column Name="QueueID" DataType="Int32" >@[User::intQueueID]</Column>
													<Column Name="ErrorType" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)("Failed Lookup <#=FKColumn["ForeignKeyColumn"]#>")</Column>
													<Column Name="SSISErrorCode" DataType="Int32" >ErrorCode</Column>
													<Column Name="SSISErrorColumn" DataType="Int32" >ErrorColumn</Column>
												</Columns>
											</DerivedColumns>
											<RowCount Name="RC_CountErrors_<#=FKColumn["ForeignKeyColumn"]#>" VariableName="User.intErrorCount">
												 <InputPath OutputPathName="DC_AddErrorDetails_<#=FKColumn["ForeignKeyColumn"]#>.Output" />
											</RowCount>
											<OleDbDestination Name="OLE_DST_Error_<#=TableSchema#>_<#=TableName#>_<#=FKColumn["ForeignKeyColumn"]#>" ConnectionName="Paga_Errors" MaximumInsertCommitSize="200"  TableLock="false">
												  <InputPath OutputPathName="RC_CountErrors_<#=FKColumn["ForeignKeyColumn"]#>.Output" />
												<ExternalTableOutput Table="[Errors].[<#=errTable#>]" />
											</OleDbDestination>
											<# } 					 
												strLookup_U = "LKP_" + FKColumn["ForeignKeyColumn"] + ".Match";
											#>
												<!-- end lookup for each-->
									<# } 
					
										string Schema_Table_U = TableSchema +"_" +TableName;
										string SchemaQualifiedName_U = "Updates." +TableSchema +"_" +TableName;
									#> 
									<OleDbDestination Name="OLE_DST_<#=Schema_Table_U#>" ConnectionName="Paga_Staging">
										<InputPath OutputPathName="<#=strLookup_U#>" />
										<ExternalTableOutput Table="<#=SchemaQualifiedName_U#>" />
										<ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
									</OleDbDestination>

		
									<OleDbDestination Name="OLE_DST_Singleton_<#=Schema_Table_U#>" ConnectionName="Paga_Staging" MaximumInsertCommitSize="1">
									  <InputPath OutputPathName="OLE_DST_<#=Schema_Table_U#>.Error" />
									  <ExternalTableOutput Table="<#=SchemaQualifiedName_U#>" />
									  <ErrorHandling ErrorRowDisposition="RedirectRow" TruncationRowDisposition="RedirectRow" />
									</OleDbDestination>

									<DerivedColumns Name="DC_AddErrorDetails">
									  <InputPath OutputPathName="OLE_DST_Singleton_<#=Schema_Table_U#>.Error" />
									  <Columns>
										<Column Name="PackageName" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)@[System::PackageName]</Column>
										<Column Name="QueueID" DataType="Int32" >@[User::intQueueID]</Column>
										<Column Name="ErrorType" DataType="AnsiString" Length="255" >(DT_STR, 255, 1252)("Insert")</Column>
										<Column Name="SSISErrorCode" DataType="Int32" >OLE_DST_Singleton_<#=Schema_Table_U#>.ErrorCode</Column>
										<Column Name="SSISErrorColumn" DataType="Int32" >OLE_DST_Singleton_<#=Schema_Table_U#>.ErrorColumn</Column>
									  </Columns>
									</DerivedColumns>
									<RowCount Name="RC_CountErrors" VariableName="User.intErrorCount">
									  <InputPath OutputPathName="DC_AddErrorDetails.Output" />
									</RowCount>

									<OleDbDestination Name="OLE_DST_Error_<#=Schema_Table_U#>" ConnectionName="Paga_Errors" MaximumInsertCommitSize="200" TableLock="false">
										  <InputPath OutputPathName="RC_CountErrors.Output" />
										  <ExternalTableOutput Table="[Errors].[<#=Schema_Table_U#>]" />
									</OleDbDestination>
							
									</Transformations>
				
							</Dataflow>
							<ExecuteSQL Name="EST_UpdateChangedRows" ConnectionName="Paga_EDW" DelayValidation="true">
								 <VariableInput VariableName="User.UpdateQuery"></VariableInput>
								<PrecedenceConstraints>
									<Inputs>
										<Input OutputPathName="DFT_Load_<#=TableSchema#>_<#=TableName#>.Output" />
									</Inputs>
								</PrecedenceConstraints>
							</ExecuteSQL>
						</Tasks>
					</Container>
				</Tasks>
			</Container>
			
			<Container Name="SEQ_Set_Deleted_Rows_Inactive" ConstraintMode="Parallel" DelayValidation="true">
				<PrecedenceConstraints>
					<Inputs>
						<Input OutputPathName="SEQ_Update_Changed_Rows.Output"> </Input>
					</Inputs>
				</PrecedenceConstraints>
				<Tasks>
					<Expression Name="ET_Set_ChangeOperation" Expression="@[User::ChangeOperation] = &quot;D&quot;" DelayValidation="true"></Expression>
					<ExecuteSQL Name="EST_CheckForDeletes" ConnectionName="Paga_Staging" ResultSet="SingleRow">
						<VariableInput VariableName="User.GetRowCount" /><Results><Result Name="_count" VariableName="User.RowCount"/></Results>
						<PrecedenceConstraints>
							<Inputs>
								<Input OutputPathName="ET_Set_ChangeOperation.Output" />
							</Inputs>
						</PrecedenceConstraints>
					</ExecuteSQL>
					<ExecuteSQL Name="EST_SetDeletedRowsToInactive" ConnectionName="Paga_EDW" DelayValidation="true">
						 <VariableInput VariableName="User.InactiveQuery"></VariableInput>
						<PrecedenceConstraints>
							<Inputs>
								<Input OutputPathName="EST_CheckForDeletes.Output" EvaluationOperation="ExpressionAndConstraint" EvaluationValue="Success" Expression="@[User::RowCount] > 0"/>
							</Inputs>
						</PrecedenceConstraints>
					</ExecuteSQL>
				</Tasks>
			</Container>
		</Tasks>
	</Package>	
<#  } #>
</Packages>
	
</Biml>
<#@ import namespace="System.Data" #>
<#@ import namespace="Varigence.Hadron.CoreLowerer.SchemaManagement" #>
